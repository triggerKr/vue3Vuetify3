1) ìš”ì•½ â€” í•µì‹¬ ìœ„í—˜ê³¼ ê¶Œì¥ ë°©í–¥

ë¦¬ì†ŒìŠ¤/ì„±ëŠ¥: ìš”ì²­ë§ˆë‹¤ TibrvTransport/TibrvListenerë¥¼ ìƒˆë¡œ ë§Œë“œëŠ” ê²ƒì€ ë¹„ìš©(ìƒì„±/ì†Œë©¸ ì˜¤ë²„í—¤ë“œ)ê³¼ ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜ ìœ„í—˜ì´ í½ë‹ˆë‹¤.
â†’ êµì²´: TransportëŠ” ì¬ì‚¬ìš©, ListenerëŠ” ì¤‘ì•™ì§‘ì¤‘í˜•(ì‹±ê¸€) ë¦¬ìŠ¤ë„ˆ + correlationId ë§¤ì¹­ ë°©ì‹ ê¶Œì¥.

ê²½ìŸ ì¡°ê±´(race): ì‘ë‹µ ë„ì°©(onMsg)ê³¼ ìŠ¤ì¼€ì¤„ëŸ¬ì˜ íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬ ì‹œì ì´ ê²¹ì¹˜ë©´ listener.destroy()/map ì œê±° ì‹œ race ë°œìƒ ê°€ëŠ¥.
â†’ í•´ê²°: ConcurrentHashMap + ScheduledFuture ì €ì¥ í›„ cancel() + map.remove(key, value) ë“± ì›ìì  ì œê±°.

dispatch í˜¸ì¶œ ìœ„ì¹˜: ì´ë¯¸ ì „ìš© Dispatch ìŠ¤ë ˆë“œë¥¼ ë„ì› ë‹¤ë©´ ë‹¤ë¥¸ ê³³(ìš”ì²­ ë³´ë‚¸ ìŠ¤ë ˆë“œ)ì—ì„œ Tibrv.defaultQueue().dispatch()ë¥¼ í˜¸ì¶œí•˜ë©´ ë¸”ë¡œí‚¹/ì¬ì§„ì… ë¬¸ì œë¥¼ ìœ ë°œí•  ìˆ˜ ìˆìŒ.
â†’ ê¶Œì¥: dispatchëŠ” ì˜¤ë¡œì§€ í•œ ìŠ¤ë ˆë“œì—ì„œë§Œ ìˆ˜í–‰.

ë¸”ë¡œí‚¹ ì‘ì—… ì£¼ì˜: dispatch ì½œë°±(onMsg) ë‚´ë¶€ì—ì„œ messagePublisher.sendToClients() ê°™ì€ ë¸”ë¡œí‚¹/ëŠë¦° ì‘ì—…ì„ ë°”ë¡œ í•˜ë©´ dispatch ìŠ¤ë ˆë“œë¥¼ ë§‰ì•„ ì „ì²´ ë©”ì‹œì§€ ì²˜ë¦¬ ì§€ì—° ìœ ë°œ.
â†’ ê¶Œì¥: ë¹„ë™ê¸° ì˜¤í”„ë¡œë“œ(executor) ì‚¬ìš©.

ê´€ë¦¬/ê´€ì¸¡: pendingRequests ì¦ê°€, íƒ€ì„ì•„ì›ƒ ë¹ˆë°œ, transport ì—ëŸ¬ ë“±ì— ëŒ€í•œ ëª¨ë‹ˆí„°ë§Â·ë¡œê¹… í•„ìš”.
â†’ ê¶Œì¥: ì¹´ìš´í„°/ì§€í‘œ(í˜„ì¬ pending ê±´ìˆ˜, íƒ€ì„ì•„ì›ƒë¥  ë“±) ì¶”ê°€.

2) êµ¬ì²´ì  ë¬¸ì œì  + í•´ê²°ì±… (í•­ëª©ë³„, ë‹¨ê³„ì )
2.1 pendingRequests ë™ì‹œì„± & ë©”ëª¨ë¦¬ ëˆ„ìˆ˜

ë¬¸ì œ: HashMap/ë™ê¸°í™” ì—†ì´ ì‚¬ìš©í•˜ë©´ race / ConcurrentModification. íƒ€ì„ì•„ì›ƒ ìŠ¤ì¼€ì¤„ì´ ì·¨ì†Œë˜ì§€ ì•Šìœ¼ë©´ ScheduledFutureê°€ ë‚¨ì•„ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°€ëŠ¥.

í•´ê²°:

ConcurrentHashMap<String, PendingRequest> ì‚¬ìš©.

PendingRequestì— CompletableFuture<TibrvMsg> ë˜ëŠ” ì½œë°±, ê·¸ë¦¬ê³  ScheduledFuture<?> timeoutTask ë³´ê´€.

ì‘ë‹µ ë°›ìœ¼ë©´ timeoutTask.cancel(false); pendingRequests.remove(corrId, pendingRequest); ë¡œ ì•ˆì „íˆ ì œê±°.

íƒ€ì„ì•„ì›ƒ ì‹¤í–‰ ì‹œì—ë„ pendingRequests.remove(corrId, pendingRequest)ì˜ ë°˜í™˜ê°’ìœ¼ë¡œ ì œê±° ì„±ê³µ ì—¬ë¶€ë¥¼ ê²€ì‚¬í•´, ì´ë¯¸ ì‘ë‹µì´ ì²˜ë¦¬ëëŠ”ì§€ í™•ì¸.

2.2 listener ìƒì„±/ì†Œë©¸ì˜ ë°˜ë³µ(ìŠ¤ì¼€ì¼/ì„±ëŠ¥ ë¬¸ì œ) ë° race

ë¬¸ì œ: ìš”ì²­ë‹¹ listener ìƒì„±/íŒŒê´´ â†’ ë¦¬ì†ŒìŠ¤ ê³¼ë‹¤Â·ì„±ëŠ¥ ì €í•˜. ì‘ë‹µ-íƒ€ì„ì•„ì›ƒ ë™ì‹œ ì‹¤í–‰ ì‹œ listener.destroy() ê°„ì„­.

í•´ê²°:

ê¶Œì¥ êµ¬ì¡°: ëª¨ë“  ì‘ë‹µì„ ì²˜ë¦¬í•  ë‹¨ì¼(ë˜ëŠ” í’€ ê¸°ë°˜) reply-listener í•˜ë‚˜ë§Œ ë„ì›€. ë©”ì‹œì§€ì— correlationId í—¤ë”ë¥¼ ë¶™ì—¬ì„œ pendingRequestsì—ì„œ ë§¤ì¹­.

ì¥ì : listener churn ì œê±°, race ê°ì†Œ, ê´€ë¦¬/ë¡œê¹… ì‰¬ì›€.

2.3 TibrvTransport ì¬ì‚¬ìš©

ë¬¸ì œ: transportë¥¼ ë§¤ ìš”ì²­ë§ˆë‹¤ ìƒˆë¡œ ìƒì„±í•˜ë©´ ìì›Â·ì—°ê²° ë¶€ë‹´.

í•´ê²°: ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ì—ì„œ transport ì¸ìŠ¤í„´ìŠ¤ í•˜ë‚˜(í˜¹ì€ í•„ìš” ì‹œ ì†Œìˆ˜) ìƒì„± í›„ ì¬ì‚¬ìš©. (ë™ì‹œì„±/ì“°ë ˆë“œ ì•ˆì „ì„±ì€ ì‚¬ìš©í•˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¬¸ì„œ í™•ì¸ ê¶Œì¥ â€” ëŒ€ì²´ë¡œ send ëŠ” ì¬ì‚¬ìš© ê°€ëŠ¥)

2.4 dispatch í˜¸ì¶œ ìœ„ì¹˜

ë¬¸ì œ: ë©”ì¸ì— ì´ë¯¸ RV-Dispatch-Threadë¥¼ ë‘ì—ˆëŠ”ë°, ë‹¤ë¥¸ ì½”ë“œì—ì„œ Tibrv.defaultQueue().dispatch();ë¥¼ í˜¸ì¶œí•˜ë©´ ì¬ì§„ì… ë˜ëŠ” ë¸”ë¡œí‚¹ ë¬¸ì œê°€ ìƒê¸¸ ìˆ˜ ìˆìŒ.

í•´ê²°: dispatchëŠ” ì˜¤ì§ dispatch ì „ìš© ìŠ¤ë ˆë“œì—ì„œë§Œ í˜¸ì¶œ. ë‹¤ë¥¸ ê³³ì—ì„œ ì´ë²¤íŠ¸ë¥¼ ì¦‰ì‹œ ì²˜ë¦¬í•˜ë ¤ëŠ” ìœ í˜¹ì´ ìˆë”ë¼ë„(ì˜ˆ: í…ŒìŠ¤íŠ¸ìš©) ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œëŠ” í˜¸ì¶œí•˜ì§€ ë§ ê²ƒ.

2.5 íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬ race

ë¬¸ì œ: ì‘ë‹µê³¼ ê±°ì˜ ë™ì‹œ ë°œìƒ ì‹œ ë‘˜ ë‹¤ ì²˜ë¦¬ë  ìˆ˜ ìˆìŒ(ì¤‘ë³µ ë³´ë‚´ê¸°, listener.destroy ì¤‘).

í•´ê²°:

ScheduledFutureë¥¼ pendingRequestsì— ì €ì¥í•˜ì—¬ ì‘ë‹µ ìˆ˜ì‹  ì‹œ ì¦‰ì‹œ cancel() í˜¸ì¶œ.

íƒ€ì„ì•„ì›ƒ í•¸ë“¤ëŸ¬ëŠ” map.remove(corrId, pr)ì´ ì„±ê³µí–ˆì„ ë•Œë§Œ Timeout í–‰ë™ ìˆ˜í–‰(ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì´ë¯¸ ì œê±°í–ˆë‹¤ë©´ ì•„ë¬´ê²ƒë„ ì•ˆ í•¨).

2.6 dispatch ì½œë°± ë‚´ë¶€ì˜ ë¸”ë¡œí‚¹ ì‘ì—…

ë¬¸ì œ: messagePublisher.sendToClients()ê°€ ëŠë¦¬ë©´ dispatch ìŠ¤ë ˆë“œê°€ ë§‰í˜€ ì „ì²´ ì‘ë‹µ ì²˜ë¦¬ ì§€ì—°.

í•´ê²°: ë©”ì‹œì§€ ì „ì†¡ì€ dispatch ìŠ¤ë ˆë“œì—ì„œ ë¹ ë¥´ê²Œ ìœ„ì„(ë¹„ë™ê¸° íì— ë„£ê¸°). ë³„ë„ ExecutorServiceë¡œ ë¹„ë™ê¸° ì „ì†¡.

2.7 ì¥ì• Â·ì˜ˆì™¸ ì²˜ë¦¬

ë¬¸ì œ: transport.send() ì‹¤íŒ¨, Tibrv ì˜ˆì™¸ ë“±ì—ì„œ pendingRequests cleanup ëˆ„ë½ ê°€ëŠ¥.

í•´ê²°:

transport.send() í˜¸ì¶œì€ try-catch. ì‹¤íŒ¨ ì‹œ pendingRequestsì—ì„œ ì œê±°í•˜ê³ (ë˜ëŠ” ì‹¤íŒ¨ ì‘ë‹µì„ í´ë¼ì´ì–¸íŠ¸ì— ë³´ëƒ„), ScheduledFuture ì·¨ì†Œ.

ì „ì²´ ì‹œìŠ¤í…œ shutdown ì‹œ @PreDestroyë¡œ pendingRequests ì „ë¶€ íƒ€ì„ì•„ì›ƒ/ì·¨ì†Œ ì²˜ë¦¬.

2.8 ìŠ¤ë¡œí‹€ë§ / DoS ëŒ€ë¹„

ë¬¸ì œ: í”„ë¡ íŠ¸ì—ì„œ ìš”ì²­ í­ì£¼ ì‹œ pendingRequestsê°€ ìŒ“ì—¬ ë©”ëª¨ë¦¬/ë¦¬ì†ŒìŠ¤ ì†Œì§„.

í•´ê²°:

ìµœëŒ€ pending size ì œí•œ(ì˜ˆ: 10k). ì´ˆê³¼ ì‹œ ì¦‰ì‹œ ì—ëŸ¬ ì‘ë‹µ ë˜ëŠ” íì‰/ê±°ì ˆ.

í´ë¼ì´ì–¸íŠ¸ë³„ ë˜ëŠ” ì „ì²´ ì“°ë£¨í’‹ ì œí•œ ì„¤ì •.

2.9 ë¡œê¹…Â·ëª¨ë‹ˆí„°ë§

pending count, average latency, timeout count, transport failures ë“± ë©”íŠ¸ë¦­ ìˆ˜ì§‘.

ë¡œê·¸ì—ëŠ” correlationId í¬í•¨.

3) ê¶Œì¥ ì•„í‚¤í…ì²˜ â€” ê°„ë‹¨í•œ ì˜ˆì‹œ ì½”ë“œ

ì•„ë˜ ì½”ë“œëŠ” ê¶Œì¥ íŒ¨í„´(ë‹¨ì¼ transport, ë‹¨ì¼ reply listener, pendingRequests + ScheduledFuture, dispatch ì „ìš© ìŠ¤ë ˆë“œ, ë¹„ë™ê¸° í´ë¼ì´ì–¸íŠ¸ ë°œì†¡)ì„ ì‹¤ë¬´ì ìœ¼ë¡œ ì ìš©í•œ ì˜ˆì‹œì…ë‹ˆë‹¤. (ë¼ì´ë¸ŒëŸ¬ë¦¬ ì •í™•í•œ API ì´ë¦„ì€ ì‚¬ìš©í•˜ì‹œëŠ” Tibrv Java ë˜í¼ì— ë”°ë¼ ì•½ê°„ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìœ¼ë‹ˆ, í•„ìš”í•œ ë¶€ë¶„ë§Œ ì ìš©í•˜ì„¸ìš”.)

// í•„ë“œ
private final ConcurrentMap<String, PendingRequest> pendingRequests = new ConcurrentHashMap<>();
private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(10);
private final ExecutorService publisherExecutor = Executors.newCachedThreadPool();
private Thread dispatchThread;
private TibrvTransport transport;    // ì¬ì‚¬ìš©
private TibrvQueue queue;

// PendingRequest helper
static class PendingRequest {
    final CompletableFuture<TibrvMsg> future = new CompletableFuture<>();
    final long createdAt = System.currentTimeMillis();
    volatile ScheduledFuture<?> timeoutTask;
}

@PostConstruct
public void init() {
    Tibrv.open(Tibrv.IMPL_NATIVE);
    queue = Tibrv.defaultQueue();
    transport = createTransport(); // í•œ ë²ˆ ìƒì„±, ì¬ì‚¬ìš©

    // ë‹¨ì¼ reply listener: ëª¨ë“  replyë¥¼ ì—¬ê¸°ì„œ ì²˜ë¦¬ (ë©”ì‹œì§€ì— correlationId í—¤ë” í•„ìš”)
    new TibrvListener(queue, new TibrvMsgCallback() {
        public void onMsg(TibrvListener listener, TibrvMsg msg) {
            String corrId = safeGetCorrelationId(msg);
            if (corrId == null) {
                // ë¡œê¹… ë° ë¬´ì‹œ ë˜ëŠ” ë³„ë„ ì²˜ë¦¬
                return;
            }
            PendingRequest pr = pendingRequests.remove(corrId);
            if (pr != null) {
                // íƒ€ì„ì•„ì›ƒ ì‘ì—… ì·¨ì†Œ
                if (pr.timeoutTask != null) pr.timeoutTask.cancel(false);

                // offload publisher to avoid blocking dispatch thread
                publisherExecutor.submit(() -> {
                    try {
                        messagePublisher.sendToClients(buildClientPayload(msg));
                    } catch (Exception e) {
                        logger.error("Failed to publish to clients for corrId=" + corrId, e);
                    } finally {
                        pr.future.complete(msg);
                    }
                });
            } else {
                logger.warn("No pending request matched for corrId=" + corrId + " (maybe timed out)");
            }
        }
    }, transport, replySubjectPattern, null);

    // Dispatch thread (í•œ ìŠ¤ë ˆë“œë§Œ)
    dispatchThread = new Thread(() -> {
        try {
            while (!Thread.currentThread().isInterrupted()) {
                Tibrv.defaultQueue().dispatch();
            }
        } catch (TibrvException e) {
            logger.error("Dispatch thread error", e);
        }
    }, "RV-Dispatch-Thread");
    dispatchThread.start();
}

public void sendRequestToRv(TibrvMsg request) {
    String corrId = UUID.randomUUID().toString();
    request.setString("correlationId", corrId);
    // reply subject could be a common subject; correlationId in header used to match

    PendingRequest pr = new PendingRequest();
    pendingRequests.put(corrId, pr);

    // ìŠ¤ì¼€ì¤„ëŸ¬ë¡œ íƒ€ì„ì•„ì›ƒ ë“±ë¡
    pr.timeoutTask = scheduler.schedule(() -> {
        // remove ì„±ê³µí•œ ê²½ìš°ì—ë§Œ íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬
        PendingRequest removed = pendingRequests.remove(corrId);
        if (removed != null) {
            // í´ë¼ì´ì–¸íŠ¸ì— íƒ€ì„ì•„ì›ƒ ì•Œë¦¼ (offload)
            publisherExecutor.submit(() -> {
                messagePublisher.sendToClients(buildTimeoutPayload(corrId));
            });
            removed.future.completeExceptionally(new TimeoutException("RV reply timeout"));
            // (listenerëŠ” ë‹¨ì¼ ë¦¬ìŠ¤ë„ˆë¼ destroy ë¶ˆí•„ìš”)
        }
    }, 10, TimeUnit.SECONDS);

    try {
        transport.send(request);
    } catch (Exception ex) {
        // ì „ì†¡ ì‹¤íŒ¨ ì‹œ ì •ë¦¬
        PendingRequest removed = pendingRequests.remove(corrId);
        if (removed != null) {
            removed.timeoutTask.cancel(false);
            removed.future.completeExceptionally(ex);
        }
        logger.error("Failed to send RV request (corrId=" + corrId + ")", ex);
    }
}

@PreDestroy
public void shutdown() {
    // ìŠ¤ë ˆë“œ ì¤‘ì§€
    if (dispatchThread != null) {
        dispatchThread.interrupt();
        try { dispatchThread.join(2000); } catch (InterruptedException ignored) {}
    }
    // pendingRequests ì •ë¦¬
    pendingRequests.forEach((k, pr) -> {
        if (pr.timeoutTask != null) pr.timeoutTask.cancel(false);
        pr.future.completeExceptionally(new IllegalStateException("Shutdown"));
    });
    pendingRequests.clear();
    scheduler.shutdownNow();
    publisherExecutor.shutdownNow();
    if (transport != null) transport.destroy(); // ë¼ì´ë¸ŒëŸ¬ë¦¬ ë©”ì„œë“œì— ë§ì¶° cleanup
    Tibrv.close();
}


ì„¤ëª… í¬ì¸íŠ¸

replySubjectPattern ë˜ëŠ” ê³µí†µ reply subjectë¥¼ ì‚¬ìš©í•˜ê³ , correlationIdë¡œ ë§¤ì¹­í•˜ê¸° ë•Œë¬¸ì— ë¦¬ìŠ¤ë„ˆë¥¼ ë§¤ ìš”ì²­ë§ˆë‹¤ ìƒì„±í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

publisherExecutorë¡œ dispatch ìŠ¤ë ˆë“œì˜ ë¸”ë¡œí‚¹ì„ ë°©ì§€í•©ë‹ˆë‹¤.

íƒ€ì„ì•„ì›ƒì€ ScheduledFutureë¡œ ë“±ë¡/ì·¨ì†Œí•©ë‹ˆë‹¤.

ì „ì†¡ ì‹¤íŒ¨ ì‹œ ì¦‰ì‹œ pendingRequestsë¥¼ ì •ë¦¬í•˜ë„ë¡ ì˜ˆì™¸ ì²˜ë¦¬í•©ë‹ˆë‹¤.

4) ì¶”ê°€ ê¶Œì¥(ìš´ì˜Â·í™•ì¥ì„±)

ëª¨ë‹ˆí„°ë§: pending size, avg latency, timeout ìˆ˜, send ì‹¤íŒ¨ìœ¨. ì•ŒëŒ ê¸°ì¤€ ì„¤ì •.

ë©”ì‹œì§€ í¬ë§·: ëª¨ë“  ë©”ì‹œì§€ì— correlationId, sentTs ë¥¼ í¬í•¨í•˜ì—¬ íŠ¸ë ˆì´ì‹± ê°€ëŠ¥í•˜ê²Œ.

ì¬ì‹œë„ ì •ì±…: transport.send() ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ ë¡œì§, ë‹¨ ì ì ˆí•œ backoff/ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ í•„ìš”.

ìŠ¤ë¡œí‹€ë§: í´ë¼ì´ì–¸íŠ¸ë³„ ë˜ëŠ” ì „ì²´ ë™ì‹œ ìš”ì²­ ì œí•œ(íì‰/ê±°ì ˆ).

í…ŒìŠ¤íŠ¸: ë™ì‹œì„±(ìˆ˜ë°±~ìˆ˜ì²œ RPS) í•˜ì—ì„œì˜ ë¶€í•˜í…ŒìŠ¤íŠ¸ë¡œ race/ë©”ëª¨ë¦¬ ì´ìŠˆ, íƒ€ì„ì•„ì›ƒë¥  í™•ì¸.

ì—ëŸ¬/ì˜ˆì™¸ ì²˜ë¦¬ í‘œì¤€í™”: íƒ€ì„ì•„ì›ƒ/ì „ì†¡ì‹¤íŒ¨/íŒŒì‹±ì˜¤ë¥˜ ë“± í´ë¼ì´ì–¸íŠ¸ë¡œ ë³´ë‚¼ í‘œì¤€ ì—ëŸ¬ í¬ë§· ì •ì˜.

5) ë§ˆë¬´ë¦¬(ìš”ì•½Â·ìš°ì„ ìˆœìœ„)

ìš°ì„ ìˆœìœ„(ë¹ ë¥´ê²Œ ì ìš© ê¶Œì¥)

ConcurrentHashMap + PendingRequest(ScheduledFuture í¬í•¨) ì ìš© â€” ì¦‰ì‹œ ì ìš© ê°€ëŠ¥.

dispatcherëŠ” í•œ ìŠ¤ë ˆë“œë§Œ í˜¸ì¶œí•˜ë„ë¡ ì½”ë“œ ì •ë¦¬(ë‹¤ë¥¸ ê³³ì˜ dispatch í˜¸ì¶œ ì œê±°).

ë¦¬ìŠ¤ë„ˆë¥¼ per-requestì—ì„œ ë‹¨ì¼ ë¦¬ìŠ¤ë„ˆë¡œ ë³€ê²½(ì‘ë‹µ ë§¤ì¹­ì€ correlationId).

dispatch ì½œë°± ë‚´ë¶€ì—ì„œì˜ blocking ì‘ì—…ì„ ë¹„ë™ê¸°ë¡œ ì˜¤í”„ë¡œë“œ.

ê·¸ ë‹¤ìŒ(ìš´ì˜Â·ì•ˆì •ì„±)

ëª¨ë‹ˆí„°ë§/ë©”íŠ¸ë¦­, ìŠ¤ë¡œí‹€ë§, ì¬ì‹œë„ ì •ì±…, shutdown ì‹œ ìì› ì •ë¦¬ ê°•í™”.

íƒœì›ë‹˜, ì›í•˜ì‹œë©´ ìœ„ íŒ¨í„´ëŒ€ë¡œ í˜„ì¬ ì½”ë“œ(ì‹¤ì œ ì†ŒìŠ¤)ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë¦¬íŒ©í† ë§í•œ êµ¬ì²´ì  ì½”ë“œë¥¼ ë°”ë¡œ ë§Œë“¤ì–´ ë“œë¦¬ê² ìŠµë‹ˆë‹¤ â€” ì˜ˆ: í˜„ì¬ ì‚¬ìš©í•˜ì‹œëŠ” TibrvTransport ìƒì„±ì/ì˜µì…˜ê³¼ messagePublisher API(ë©”ì„œë“œëª…)ë¥¼ ë¶™ì—¬ì„œ ì •í™•í•œ ì½”ë“œë¡œ ì‘ì„±í•´ ë“œë¦´ê²Œìš”. ì›í•˜ì‹œë©´ ì§€ê¸ˆ ë°”ë¡œ ì½”ë“œ ë¦¬íŒ©í† ë§(ì™„ì „í•œ í´ë˜ìŠ¤ í˜•íƒœ)í•´ ë“œë¦¬ê² ìŠµë‹ˆë‹¤. ì–´ë–¤ ë°©ì‹ìœ¼ë¡œ ì§„í–‰í• ê¹Œìš”?

ë‚˜ì˜ ë§:
ìŠ¤ì¼€ì¥´ëŸ¬ ë§ì¸ë°
private final ScheduledExecutorsService = Electors.newScheduledThreadPool(10)ì„ ìì„¸íˆ ì„¤ëª…í•´ì¤˜
ChatGPTì˜ ë§:
27s ë™ì•ˆ ìƒê°í•¨

ì¢‹ìŠµë‹ˆë‹¤, íƒœì›ë‹˜ â€” Executors.newScheduledThreadPool(10)(ë§ì”€í•˜ì‹  ScheduledExecutorsService = Electors.newScheduledThreadPool(10)ëŠ” ì˜¤íƒ€ë¡œ ë³´ì—¬ìš”)ì„ ë‹¨ê³„ë³„ë¡œ ìì„¸íˆ í’€ì–´ ì„¤ëª…ë“œë¦¬ê² ìŠµë‹ˆë‹¤. TIBRV íƒ€ì„ì•„ì›ƒìš© ìŠ¤ì¼€ì¤„ëŸ¬ë¡œ ì“°ì‹¤ ë•Œ ë°”ë¡œ ì ìš©í•  ìˆ˜ ìˆëŠ” ì‹¤ë¬´ íŒë„ í•¨ê»˜ ë“œë¦´ê²Œìš”.

1) í•œì¤„ ìš”ì•½

Executors.newScheduledThreadPool(10)ì€ ì˜ˆì•½(ì§€ì—°/ì£¼ê¸°) ì‘ì—…ì„ ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” ìŠ¤ë ˆë“œ í’€ì„ ë§Œë“¤ê³  ScheduledExecutorService ì¸í„°í˜ì´ìŠ¤ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ë‚´ë¶€ì ìœ¼ë¡œëŠ” ScheduledThreadPoolExecutorê°€ ë§Œë“¤ì–´ì§€ë©°, core pool size(ì—¬ê¸°ì„  10) ë§Œí¼ ìŠ¤ë ˆë“œë¥¼ ìœ ì§€í•˜ë©´ì„œ ì˜ˆì•½ ì‘ì—…(ì§€ì—°, ì£¼ê¸°ì  ë“±)ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.

2) ë™ì‘ ì›ë¦¬(í•µì‹¬)

ìŠ¤ë ˆë“œ ìˆ˜(corePoolSize): 10ì´ë©´ ìµœëŒ€ 10ê°œì˜ ì‘ì—…ì„ ë™ì‹œì— ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤(ë™ì‹œì— ì‹¤í–‰ë  ì‘ì—…ì´ 10ê°œ ì´ìƒì´ë©´ ë‚˜ë¨¸ì§€ëŠ” ì˜ˆì•½ íì— ìŒ“ì„).

í êµ¬ì¡°: ë‚´ë¶€ì ìœ¼ë¡œ DelayedWorkQueue(ë¬´ì œí•œ í¬ê¸°) ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. (ì¦‰, ì œì¶œëœ ì‘ì—…ì€ íì— ë¬´í•œíˆ ìŒ“ì¼ ìˆ˜ ìˆì–´ ë©”ëª¨ë¦¬ ê´€ë¦¬ëŠ” ì•± ì±…ì„)

ìŠ¤ì¼€ì¤„ë§ íƒ€ì…:

schedule(...) : ì§€ì—° í›„ í•œ ë²ˆ ì‹¤í–‰.

scheduleAtFixedRate(...) : ê³ ì • ì£¼ê¸°(ì‹¤í–‰ ì‹œì‘ ì‹œê°„ ê¸°ì¤€) â€” ì£¼ê¸°ê°€ ì§§ìœ¼ë©´ ì‘ì—…ì´ ì„œë¡œ ê²¹ì¹  ìˆ˜ ìˆìŒ.

scheduleWithFixedDelay(...) : ì´ì „ ì‹¤í–‰ì´ ëë‚œ ë’¤ ì¼ì • ì§€ì—° í›„ ë‹¤ì‹œ ì‹¤í–‰(ê²¹ì¹˜ì§€ ì•ŠìŒ).

ìŠ¤ë ˆë“œ ìƒì„±/ì¢…ë£Œ: í•„ìš”ì‹œì— core ë§Œí¼ ìŠ¤ë ˆë“œë¥¼ ë§Œë“¤ê³ (ìš”êµ¬ ì—†ìœ¼ë©´ ë§Œë“¤ì§€ ì•ŠìŒ), ê¸°ë³¸ ì“°ë ˆë“œ íŒ©í† ë¦¬ëŠ” non-daemon ìŠ¤ë ˆë“œ ìƒì„±.

3) ScheduledFutureì™€ ì·¨ì†Œ semantics

schedule(...) ë“±ì€ ScheduledFuture<?>ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ì´ ê°ì²´ë¡œ cancel(boolean mayInterruptIfRunning)ì„ í˜¸ì¶œí•´ ì‘ì—…ì„ ì·¨ì†Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

cancel(false) : ì´ë¯¸ ì‹œì‘ëœ ì‘ì—…ì€ ì¤‘ë‹¨ë˜ì§€ ì•ŠìŒ. cancel(true)ëŠ” ì‹œì‘ëœ ì‘ì—…ì„ interrupt() ì‹œë„í•¨(ì‘ì—…ì´ ì¸í„°ëŸ½íŠ¸ë¥¼ ì²´í¬í•´ì•¼ íš¨ê³¼ ìˆìŒ).

ì£¼ê¸° ì‘ì—…ì˜ ê²½ìš°, ScheduledFuture.get()ì€ ì‚¬ì‹¤ìƒ ì™„ë£Œë˜ì§€ ì•Šê¸° ë•Œë¬¸ì—(ì£¼ê¸°ì ìœ¼ë¡œ ê³„ì† ë™ì‘) cancel()ë¡œ ì¤‘ë‹¨í•´ì•¼ í•©ë‹ˆë‹¤.

4) ìì£¼ ë°œìƒí•˜ëŠ” ë¬¸ì œ & ëŒ€ì±… (TIBRV íƒ€ì„ì•„ì›ƒì— ì§ì ‘ ì—°ê²°ë˜ëŠ” ë¶€ë¶„)

ì£¼ê¸°/ì˜ˆì•½ ì‘ì—…ì´ ì˜ˆì™¸ë¥¼ ë˜ì§€ë©´(ëŸ°íƒ€ì„ ì˜ˆì™¸)

scheduleAtFixedRate / scheduleWithFixedDelayì—ì„œ Runnableì´ ì˜ˆì™¸ë¥¼ ë˜ì§€ë©´ ì´í›„ ë°˜ë³µ ì‹¤í–‰ì´ ì¤‘ë‹¨ë©ë‹ˆë‹¤.

â†’ ëŒ€ì±…: ì£¼ê¸°/ì˜ˆì•½ ì‘ì—… ë‚´ë¶€ì—ì„œ ë°˜ë“œì‹œ try { ... } catch(Throwable t) { log }ë¡œ ì˜ˆì™¸ë¥¼ ì¡ì•„ì¤˜ì•¼ í•©ë‹ˆë‹¤.

ì‘ì—… ì·¨ì†Œ í›„ íì—ì„œ ì œê±°ë˜ì§€ ì•Šì•„ ë©”ëª¨ë¦¬ì— ë‚¨ëŠ” ë¬¸ì œ

ScheduledThreadPoolExecutorëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ì·¨ì†Œëœ ì‘ì—…ì„ ì¦‰ì‹œ íì—ì„œ ì œê±°í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ.

â†’ ëŒ€ì±…: ((ScheduledThreadPoolExecutor)scheduler).setRemoveOnCancelPolicy(true); ì„¤ì • ê¶Œì¥.

ë¬´í•œíˆ ìŒ“ì´ëŠ” í(ë©”ëª¨ë¦¬ ë¬¸ì œ)

DelayedWorkQueueëŠ” ê±°ì˜ ë¬´ì œí•œì´ë¯€ë¡œ submitì„ ì œì–´í•˜ì§€ ì•Šìœ¼ë©´ OOM ë°œìƒ ê°€ëŠ¥.

â†’ ëŒ€ì±…: ì™¸ë¶€ì—ì„œ pending ìˆ˜ ì œí•œ, ê±°ë¶€ ë¡œì§ì„ êµ¬í˜„í•˜ê±°ë‚˜ ì‘ì—…ì„ ê°€ë²¼ìš´ í˜•íƒœë¡œ ìœ ì§€.

ê¸´ ì‘ì—…ì´ ë§ì€ë° ìŠ¤ë ˆë“œ ìˆ˜ê°€ ì‘ìœ¼ë©´ ì‘ì—…ì´ ë°€ë¦¼

íƒ€ì„ì•„ì›ƒ í•¸ë“¤ëŸ¬ê°€ ë¬´ê²ë‹¤ë©´ ìŠ¤ë ˆë“œ ìˆ˜ë¥¼ ëŠ˜ë¦¬ê±°ë‚˜, ìŠ¤ì¼€ì¤„ëŸ¬ëŠ” â€œë¹ ë¥´ê²Œâ€ timeout ì²˜ë¦¬(ì˜ˆ: ë‹¨ìˆœíˆ cancel í”Œë˜ê·¸ + ì˜¤í”„ë¡œë“œ)ë§Œ í•˜ê³  ì‹¤ì œ ë¬´ê±°ìš´ I/O ì‘ì—…ì€ ë³„ë„ executorì— ë„˜ê¸°ëŠ” êµ¬ì¡° ê¶Œì¥.

shutdown ì²˜ë¦¬

shutdown() í˜¸ì¶œí•˜ë©´ ìƒˆ ì‘ì—… ìˆ˜ë½ì„ ì¤‘ì§€í•˜ê³  ì´ë¯¸ ì œì¶œëœ ì‘ì—…ì€ ì‹¤í–‰. shutdownNow()ëŠ” ì‹œë„ ì¤‘ë‹¨.

awaitTermination(...)ìœ¼ë¡œ ìš°ì•„í•œ ì¢…ë£Œ ì‹œë„ í•„ìš”.

5) ì‹¤ì „ ê¶Œì¥ ì„¤ì • + ì½”ë“œ ì˜ˆì‹œ

íƒ€ì„ì•„ì›ƒ ìš©ë„ë¡œ ì“°ì‹¤ ë•Œ(íƒœì›ë‹˜ êµ¬ì¡°ì²˜ëŸ¼ pendingRequestsë§ˆë‹¤ ScheduledFuture ì €ì¥) ë°”ë¡œ ì“°ê¸° ì¢‹ì€ ì˜ˆì‹œì…ë‹ˆë‹¤.

import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

// ìŠ¤ì¼€ì¤„ëŸ¬ ìƒì„± (ìŠ¤ë ˆë“œëª… ì§€ì •, ì˜ˆì™¸ ë¡œê¹… ê°€ëŠ¥)
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(
    10,
    new ThreadFactory() {
        private final AtomicInteger idx = new AtomicInteger(1);
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r, "rv-scheduler-" + idx.getAndIncrement());
            t.setDaemon(false); // trueë¡œ í•˜ë©´ JVM ì¢…ë£Œ ì‹œ í•´ë‹¹ ìŠ¤ë ˆë“œê°€ ê°•ì œ ì¢…ë£Œë¨
            t.setUncaughtExceptionHandler((th, ex) -> {
                // ì˜ˆì™¸ ë¡œê¹…: ì£¼ê¸° ì‘ì—…ì—ì„œ ì˜ˆì™¸ ë°œìƒì‹œ íë¦„ í™•ì¸ìš©
                logger.error("Uncaught in scheduler thread " + th.getName(), ex);
            });
            return t;
        }
    }
);

// ì¶”ê°€ ì„¤ì • (ì·¨ì†Œëœ ì‘ì—…ì„ íì—ì„œ ì œê±°)
if (scheduler instanceof ScheduledThreadPoolExecutor) {
    ScheduledThreadPoolExecutor stpe = (ScheduledThreadPoolExecutor) scheduler;
    stpe.setRemoveOnCancelPolicy(true);
    // ì¢…ë£Œ ì‹œ ê¸°ì¡´ ì˜ˆì•½ ì‘ì—… ì‹¤í–‰ ì—¬ë¶€ ì„¤ì • (í™˜ê²½ì— ë”°ë¼)
    stpe.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);
    stpe.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
}

// ì‘ì—… ìŠ¤ì¼€ì¤„ ì˜ˆ: íƒ€ì„ì•„ì›ƒ ë“±ë¡
ScheduledFuture<?> timeoutFuture = scheduler.schedule(() -> {
    try {
        // íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬ ì½”ë“œ (ì‘ì—…ì€ ê°€ë³ê²Œ ìœ ì§€)
        handleTimeout(corrId);
    } catch (Throwable t) {
        logger.error("Timeout handler failed for " + corrId, t);
    }
}, 10, TimeUnit.SECONDS);

// íƒ€ì„ì•„ì›ƒ ì·¨ì†Œ(ì‘ë‹µ ë°›ì•˜ì„ ë•Œ)
timeoutFuture.cancel(false); // false: ì´ë¯¸ ì‹œì‘ëœ ê²½ìš° ì¸í„°ëŸ½íŠ¸ ì•ˆ í•¨


ì£¼ê¸° ì‘ì—… ì˜ˆì‹œ (ì˜ˆì™¸ ë°©ì§€ í•„ìˆ˜)

ScheduledFuture<?> periodic = scheduler.scheduleAtFixedRate(() -> {
    try {
        doPeriodicCheck();
    } catch (Throwable t) {
        logger.error("periodic task error", t);
        // ì£¼ì˜: ì˜ˆì™¸ë¥¼ ë‹¤ì‹œ ë˜ì§€ë©´ ìŠ¤ì¼€ì¤„ì´ ì¤‘ë‹¨ë¨ â€” ë°˜ë“œì‹œ ì¡ì•„ì„œ ëë‚´ì„¸ìš”.
    }
}, 0, 5, TimeUnit.SECONDS);


ê·¸ë ˆì´ìŠ¤í’€ ì¢…ë£Œ ì˜ˆì‹œ

scheduler.shutdown();
try {
    if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
        List<Runnable> dropped = scheduler.shutdownNow(); // ê°•ì œ ì¢…ë£Œ
        logger.warn("Scheduler forced shutdown, dropped tasks: " + dropped.size());
    }
} catch (InterruptedException e) {
    scheduler.shutdownNow();
    Thread.currentThread().interrupt();
}

6) ìŠ¤ë ˆë“œ í’€ í¬ê¸° ì„ ì • ê°€ì´ë“œ (ê°„ë‹¨)

CPU-bound ì‘ì—…ì´ë©´ N â‰ˆ availableProcessors() ê°€ ì ì ˆ.

I/O / ë¸”ë¡œí‚¹ ì‘ì—…ì´ë©´ Nì„ í›¨ì”¬ í¬ê²Œ ì¡ì•„ë„ ë¨(ì˜ˆ: cores * (1 + waitTime/computeTime) ì‹ìœ¼ë¡œ ê³„ì‚°í•˜ê±°ë‚˜ ê²½í—˜ì ìœ¼ë¡œ ì¡°ì ˆ).

ë‹¨, íƒ€ì„ì•„ì›ƒ í•¸ë“¤ëŸ¬ëŠ” ë³´í†µ ê°€ë³ê²Œ(ì·¨ì†Œ, ë©”ì‹œì§€ ë°œì†¡ ìœ„ì„) ì‘ì„±í•˜ë¯€ë¡œ 10ì€ ë³´ìˆ˜ì ìœ¼ë¡œ ì¶©ë¶„í•œ í¸ì…ë‹ˆë‹¤. ë‹¤ë§Œ messagePublisher.sendToClients()ì²˜ëŸ¼ ì™¸ë¶€ë¡œ ì˜¤ë˜ê±¸ë¦¬ëŠ” ì‘ì—…ì€ ìŠ¤ì¼€ì¤„ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ì§ì ‘ ì‹¤í–‰í•˜ì§€ ë§ê³  ë³„ë„ì˜ publisherExecutorë¡œ ìœ„ì„í•˜ì„¸ìš”.

7) TIBRV êµ¬ì¡°ì— ë§ì¶˜ ê¶Œì¥ ì‚¬ìš© íŒ¨í„´ (ìš”ì•½)

scheduler.schedule(...)ë¡œ íƒ€ì„ì•„ì›ƒ ë“±ë¡ â†’ ScheduledFutureë¥¼ pendingRequests ê°ì²´ì— ë³´ê´€.

ì‘ë‹µ ìˆ˜ì‹  ì‹œ timeoutFuture.cancel(false) í•˜ê³ , pendingRequests.remove(corrId) í•˜ë©° cleanup.

íƒ€ì„ì•„ì›ƒ í•¸ë“¤ëŸ¬ ë‚´ë¶€ì—ì„œ ë¬´ê±°ìš´ ì‘ì—…ì€ ë°”ë¡œ ì‹¤í–‰í•˜ì§€ ë§ê³  publisherExecutor.submit(...)ë¡œ ìœ„ì„.

setRemoveOnCancelPolicy(true)ë¡œ ì·¨ì†Œëœ íƒ€ì„ì•„ì›ƒ ì‘ì—…ì´ íì— ë‚¨ì§€ ì•Šê²Œ í•œë‹¤.

ì£¼ê¸°/ì˜ˆì•½ ì‘ì—…ì˜ ì˜ˆì™¸ëŠ” ë°˜ë“œì‹œ ì¡ëŠ”ë‹¤(ì•ˆê·¸ëŸ¬ë©´ í•´ë‹¹ ì˜ˆì•½ì´ ì¤‘ë‹¨ë¨).

íƒœì›ë‹˜, ìœ„ ì„¤ëª…ì„ ì •ë¦¬í•˜ë©´ í•µì‹¬ì€:

ScheduledThreadPoolExecutorëŠ” ì˜ˆì•½ ì‘ì—… ì „ìš©ìœ¼ë¡œ í¸ë¦¬í•˜ê³  ê°•ë ¥í•˜ì§€ë§Œ ì˜ˆì™¸ ì²˜ë¦¬Â·ì·¨ì†Œ ì •ì±…Â·í ë¬´ì œí•œì´ë¼ëŠ” ì†ì„±ë“¤ì„ ì˜ ê´€ë¦¬í•´ì•¼ ì•ˆì „í•©ë‹ˆë‹¤.

íƒ€ì„ì•„ì›ƒ í•¸ë“¤ëŸ¬ëŠ” ê°€ë³ê²Œ, ë¬´ê±°ìš´ ì²˜ë¦¬(í´ë¼ì´ì–¸íŠ¸ ì „ì†¡ ë“±)ëŠ” ë‹¤ë¥¸ executorë¡œ ìœ„ì„í•˜ì„¸ìš”.

setRemoveOnCancelPolicy(true)ì™€ graceful shutdown ì½”ë“œëŠ” ê¼­ ë„£ìœ¼ì‹œëŠ” ê±¸ ê¶Œì¥ë“œë¦½ë‹ˆë‹¤.

ì›í•˜ì‹œë©´ íƒœì›ë‹˜ì´ ì‚¬ìš© ì¤‘ì¸ ì½”ë“œ(íŠ¹íˆ pendingRequests êµ¬ì¡°ì™€ messagePublisher API)ë¥¼ ë¶™ì—¬ì„œ ì •í™•í•˜ê²Œ ë¦¬íŒ©í† ë§ëœ ìŠ¤ë‹ˆí«(íƒ€ì…ëª…/ë©”ì„œë“œëª… ê·¸ëŒ€ë¡œ)ìœ¼ë¡œ ë§Œë“¤ì–´ ë“œë¦´ê²Œìš”. ë°”ë¡œ ë§Œë“¤ì–´ ë“œë¦´ê¹Œìš”?

ë‚˜ì˜ ë§:
ë¦¬ì†ŒìŠ¤/ì„±ëŠ¥: ìš”ì²­ë§ˆë‹¤ TibrvTransport/TibrvListenerë¥¼ ìƒˆë¡œ ë§Œë“œëŠ” ê²ƒì€ ë¹„ìš©(ìƒì„±/ì†Œë©¸ ì˜¤ë²„í—¤ë“œ)ê³¼ ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜ ìœ„í—˜ì´ í½ë‹ˆë‹¤.
â†’ êµì²´: TransportëŠ” ì¬ì‚¬ìš©, ListenerëŠ” ì¤‘ì•™ì§‘ì¤‘í˜•(ì‹±ê¸€) ë¦¬ìŠ¤ë„ˆ + correlationId ë§¤ì¹­ ë°©ì‹ ê¶Œì¥. ì´ê±°ëŠ” ì–´ë–»ê²Œ í•˜ë©´ ë¼?
ChatGPTì˜ ë§:

ì¢‹ì€ í¬ì¸íŠ¸ ì§šìœ¼ì…¨ì–´ìš” íƒœì›ë‹˜ ğŸ‘
í˜„ì¬ êµ¬ì¡°ëŠ” ìš”ì²­ë§ˆë‹¤ TibrvTransportì™€ TibrvListenerë¥¼ ìƒì„±/íŒŒê´´í•˜ê³  ìˆëŠ”ë°, ì´ëŠ” ì„±ëŠ¥/ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ ë©´ì—ì„œ ë¶€ë‹´ì´ í½ë‹ˆë‹¤. TIB/Rendezvous(RV)ì˜ ê¶Œì¥ íŒ¨í„´ì€ ë³´í†µ ì´ë ‡ê²Œ ê°‘ë‹ˆë‹¤:

1. TransportëŠ” ì¬ì‚¬ìš©

TibrvTransportëŠ” ë„¤ì´í‹°ë¸Œ ë ˆë²¨ì—ì„œ ì†Œì¼“/ë„¤íŠ¸ì›Œí¬ ë¦¬ì†ŒìŠ¤ë¥¼ ì¡ê³  ìˆê¸° ë•Œë¬¸ì—, ìš”ì²­ë§ˆë‹¤ ìƒˆë¡œ ë§Œë“¤ë©´ ë¹„ìš©ì´ í½ë‹ˆë‹¤.

ë”°ë¼ì„œ ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì‹œ í•œ ë²ˆë§Œ ìƒì„±í•´ì„œ ì „ì—­ìœ¼ë¡œ ì¬ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤.

@Component
public class RvTransportHolder {
    private final TibrvTransport transport;

    public RvTransportHolder() throws TibrvException {
        // ì˜ˆ: ì„œë¹„ìŠ¤/ë„¤íŠ¸/ë°ëª¬ ê°’ì€ í™˜ê²½ì— ë§ê²Œ ì„¤ì •
        this.transport = new TibrvRvdTransport("service", "network", "daemon");
    }

    public TibrvTransport getTransport() {
        return transport;
    }
}

2. ListenerëŠ” ì¤‘ì•™ ì§‘ì¤‘í˜•

ì§€ê¸ˆì€ ìš”ì²­ë§ˆë‹¤ TibrvListenerë¥¼ ë§Œë“¤ì–´ì„œ replySubjectì— ë°”ì¸ë”©í•˜ê³  ê³„ì‹ ë°, ëŒ€ì‹ :

ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì‹œ ê³µí†µ TibrvListenerë¥¼ ë“±ë¡í•©ë‹ˆë‹¤.

ì´ ë¦¬ìŠ¤ë„ˆëŠ” ëª¨ë“  ì‘ë‹µ ë©”ì‹œì§€ë¥¼ ë°›ìŠµë‹ˆë‹¤.

ê° ë©”ì‹œì§€ì—ëŠ” correlationId ê°™ì€ ê³ ìœ  ID(ë³´í†µ requestMsgì˜ í•„ë“œë¡œ ì„¸íŒ…)ê°€ í¬í•¨ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.

ë¦¬ìŠ¤ë„ˆëŠ” ë°›ì€ ë©”ì‹œì§€ì—ì„œ correlationIdë¥¼ ì¶”ì¶œí•´ì„œ pendingRequests ë§µì„ lookup â†’ í•´ë‹¹ ìš”ì²­ìì—ê²Œ ê²°ê³¼ë¥¼ ì „ë‹¬.

3. CorrelationId ë§¤ì¹­ ë°©ì‹

ì˜ˆì œ ì½”ë“œ íë¦„ì…ë‹ˆë‹¤:

ìš”ì²­ ì „ì†¡ ì‹œ
String correlationId = UUID.randomUUID().toString();

// ìš”ì²­ ë©”ì‹œì§€ ìƒì„±
TibrvMsg requestMsg = new TibrvMsg();
requestMsg.add("corrId", correlationId);

// pendingRequestsì— ë“±ë¡ (ì‘ë‹µ/íƒ€ì„ì•„ì›ƒ í•¸ë“¤ëŸ¬ ëŒ€ê¸°)
PendingRequest req = new PendingRequest(correlationId, futureOrCallback);
pendingRequests.put(correlationId, req);

// ë©”ì‹œì§€ ì „ì†¡
transport.send(requestMsg);

ì¤‘ì•™ ë¦¬ìŠ¤ë„ˆ
@Component
public class CentralRvListener implements TibrvMsgCallback {

    private final Map<String, PendingRequest> pendingRequests;

    public CentralRvListener(Map<String, PendingRequest> pendingRequests, RvTransportHolder transportHolder) throws TibrvException {
        // replySubjectëŠ” ì„œë²„ê°€ ì‘ë‹µì„ ë˜ì§€ëŠ” ê³µí†µ subject
        new TibrvListener(
            Tibrv.defaultQueue(),
            this, // ì½œë°±
            transportHolder.getTransport(),
            "reply.subject", 
            null
        );
        this.pendingRequests = pendingRequests;
    }

    @Override
    public void onMsg(TibrvListener listener, TibrvMsg msg) {
        try {
            String corrId = (String) msg.get("corrId");
            if (corrId != null && pendingRequests.containsKey(corrId)) {
                PendingRequest req = pendingRequests.remove(corrId);
                if (req != null) {
                    req.complete(msg); // ë©”ì‹œì§€ë¥¼ Vue3 í´ë¼ì´ì–¸íŠ¸ë¡œ ì „ë‹¬
                }
            } else {
                // ë§¤ì¹­ë˜ëŠ” ìš”ì²­ ì—†ìŒ â†’ ë¡œê·¸ ë‚¨ê¸°ê¸°
                System.err.println("Unexpected message: " + msg);
            }
        } catch (TibrvException e) {
            e.printStackTrace();
        }
    }
}

4. Timeout ê´€ë¦¬

ìŠ¤ì¼€ì¤„ëŸ¬ì— ë“±ë¡í•  ë•Œë„ ì´ì œëŠ” listener.destroy()ê°€ í•„ìš” ì—†ìŠµë‹ˆë‹¤.

ëŒ€ì‹  correlationId ê¸°ì¤€ìœ¼ë¡œë§Œ pendingRequests.remove(corrId) í•´ì£¼ë©´ ë©ë‹ˆë‹¤.

ScheduledFuture<?> timeoutFuture = scheduler.schedule(() -> {
    PendingRequest req = pendingRequests.remove(corrId);
    if (req != null) {
        req.timeout(); // Vue3 í´ë¼ì´ì–¸íŠ¸ì— Timeout ë©”ì‹œì§€ ì „ì†¡
    }
}, 10, TimeUnit.SECONDS);

5. ì¥ì 

Transport ì¬ì‚¬ìš© â†’ ë„¤íŠ¸ì›Œí¬ ë¦¬ì†ŒìŠ¤ ì ˆì•½, ì„±ëŠ¥ í–¥ìƒ.

Listener ì¤‘ì•™ì§‘ì¤‘í™” â†’ listener ìƒì„±/íŒŒê´´ ì˜¤ë²„í—¤ë“œ ì œê±°, ë¦¬ì†ŒìŠ¤ ëˆ„ìˆ˜ ë°©ì§€.

CorrelationId ë§¤ì¹­ â†’ ë™ì‹œì— ìˆ˜ë°±/ìˆ˜ì²œ ìš”ì²­ë„ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬ ê°€ëŠ¥.

íƒ€ì„ì•„ì›ƒ/ì‘ë‹µ ê´€ë¦¬ ë‹¨ìˆœí™” â†’ pendingRequestsì—ì„œë§Œ ê´€ë¦¬í•˜ë©´ ë¨.

ğŸ‘‰ ì •ë¦¬í•˜ë©´, TibrvTransportëŠ” ì‹±ê¸€í„´, TibrvListenerëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ë‹¹ í•˜ë‚˜ë§Œ ë‘ê³ , ìš”ì²­ê³¼ ì‘ë‹µ ë§¤ì¹­ì€ correlationId ê¸°ë°˜ìœ¼ë¡œ pendingRequestsì—ì„œ lookupí•˜ëŠ” ë°©ì‹ì´ ê°€ì¥ ì•ˆì •ì ì…ë‹ˆë‹¤.

íƒœì›ë‹˜, ì›í•˜ì‹œë©´ ì œê°€ ì§€ê¸ˆ ë§ì”€ë“œë¦° êµ¬ì¡°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ Spring Boot Bean êµ¬ì„± + CorrelationId ê¸°ë°˜ pendingRequests ë§¤ë‹ˆì € í´ë˜ìŠ¤ ì „ì²´ ì½”ë“œë¥¼ ë§Œë“¤ì–´ ë“œë¦´ ìˆ˜ ìˆì–´ìš”.
ê·¸ëŸ¼ ì‹¤ì „ì—ì„œ ë°”ë¡œ êµì²´ ê°€ëŠ¥í•  ê²ë‹ˆë‹¤. ë§Œë“¤ê¹Œìš”?

ë‚˜ì˜ ë§:
ë§Œë“¤ì–´ì¤˜
ChatGPTì˜ ë§:

ì¢‹ìŠµë‹ˆë‹¤ íƒœì›ë‹˜ ğŸ‘
ì œê°€ ë§ì”€ë“œë¦° Transport ì¬ì‚¬ìš© + Listener ì¤‘ì•™ ì§‘ì¤‘í˜• + correlationId ë§¤ì¹­ ë°©ì‹ì„ ìŠ¤í”„ë§ ë¶€íŠ¸ + Vue3 êµ¬ì¡°ì— ë§ì¶° ì½”ë“œ ì˜ˆì œë¡œ ë§Œë“¤ì–´ ë“œë¦´ê²Œìš”.

ì„¤ê³„ ê°œìš”

Transport

ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì‹œ @PostConstructì—ì„œ 1ê°œë§Œ ìƒì„± â†’ ì¬ì‚¬ìš©.

Listener

replySubject ì „ì²´ë¥¼ í•œ ë²ˆì— ë°›ì•„ì£¼ëŠ” ì‹±ê¸€ ë¦¬ìŠ¤ë„ˆ ìƒì„±.

ëª¨ë“  ì‘ë‹µ ë©”ì‹œì§€ë¥¼ ì´ ë¦¬ìŠ¤ë„ˆê°€ ë°›ê³ , ë©”ì‹œì§€ ì•ˆì˜ correlationId (ë˜ëŠ” header ê°’)ë¥¼ ê¸°ì¤€ìœ¼ë¡œ pendingRequestsì—ì„œ ì°¾ì•„ ì „ë‹¬.

pendingRequests ê´€ë¦¬

ConcurrentHashMap<correlationId, CompletableFuture<TibrvMsg>> ë¡œ ìš”ì²­â€“ì‘ë‹µ ë§¤í•‘.

íƒ€ì„ì•„ì›ƒ ì‹œ schedulerì—ì„œ Futureë¥¼ completeExceptionally() ì²˜ë¦¬.

í´ë¼ì´ì–¸íŠ¸ ì†¡ì‹ 

Vue3ì—ì„œ ìš”ì²­ì´ ì˜¤ë©´ ë©”ì‹œì§€ì— correlationId ë„£ì–´ì„œ ì „ì†¡.

ì‘ë‹µ ì˜¤ë©´ Future complete â†’ WebSocket/SSE í†µí•´ í”„ë¡ íŠ¸ì—”ë“œë¡œ ì „ë‹¬.

ì½”ë“œ ì˜ˆì‹œ
import com.tibco.tibrv.*;
import jakarta.annotation.PostConstruct;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.*;

@Service
public class RvService {

    private TibrvTransport transport;
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(10);
    private final Map<String, CompletableFuture<TibrvMsg>> pendingRequests = new ConcurrentHashMap<>();

    @PostConstruct
    public void init() throws TibrvException {
        // ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ˆê¸°í™”
        Tibrv.open(Tibrv.IMPL_NATIVE);

        // ê³µìš© Transport ìƒì„±
        transport = new TibrvRvdTransport("7500", "127.0.0.1", null);

        // ì‘ë‹µ ë¦¬ìŠ¤ë„ˆ (replySubjectë¥¼ í•œ ë²ˆë§Œ êµ¬ë…)
        new TibrvListener(
                Tibrv.defaultQueue(),
                this::onResponseMsg,
                transport,
                "MY.REPLY.SUBJECT",
                null
        );

        // RV dispatch ìŠ¤ë ˆë“œ ì‹œì‘
        new Thread(() -> {
            while (true) {
                try {
                    Tibrv.defaultQueue().dispatch();
                } catch (TibrvException e) {
                    e.printStackTrace();
                }
            }
        }, "RV-Dispatch-Thread").start();
    }

    /** Vue3 â†’ ì„œë²„ ìš”ì²­ ì²˜ë¦¬ */
    public void sendRequest(String payload, MessagePublisher publisher) throws TibrvException {
        String correlationId = UUID.randomUUID().toString();

        // ìš”ì²­ ë©”ì‹œì§€ ìƒì„±
        TibrvMsg requestMsg = new TibrvMsg();
        requestMsg.setSendSubject("MY.REQUEST.SUBJECT");
        requestMsg.update("correlationId", correlationId);
        requestMsg.update("data", payload);
        requestMsg.setReplySubject("MY.REPLY.SUBJECT");

        // Future ìƒì„± ë° pendingì— ë“±ë¡
        CompletableFuture<TibrvMsg> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, future);

        // íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬
        scheduler.schedule(() -> {
            CompletableFuture<TibrvMsg> f = pendingRequests.remove(correlationId);
            if (f != null && !f.isDone()) {
                f.completeExceptionally(new TimeoutException("Request timeout"));
                publisher.sendToClients("TIMEOUT: " + payload);
            }
        }, 10, TimeUnit.SECONDS);

        // RVë¡œ ì†¡ì‹ 
        transport.send(requestMsg);

        // ì‘ë‹µ ì™„ë£Œ ì‹œ Vue3ë¡œ ì „ë‹¬
        future.whenComplete((msg, ex) -> {
            if (ex == null) {
                publisher.sendToClients(msg.toString()); // ì›í•˜ëŠ” ë³€í™˜ ì²˜ë¦¬
            } else {
                publisher.sendToClients("ERROR: " + ex.getMessage());
            }
        });
    }

    /** ì‘ë‹µ ë¦¬ìŠ¤ë„ˆ ì½œë°± */
    private void onResponseMsg(TibrvListener listener, TibrvMsg msg) {
        try {
            String correlationId = (String) msg.get("correlationId");
            CompletableFuture<TibrvMsg> future = pendingRequests.remove(correlationId);
            if (future != null) {
                future.complete(msg);
            }
        } catch (TibrvException e) {
            e.printStackTrace();
        }
    }
}

ê°œì„ ëœ ì 

ğŸš€ TransportëŠ” 1ê°œë§Œ ìƒì„± í›„ ì¬ì‚¬ìš© â†’ ë¦¬ì†ŒìŠ¤ ì ˆì•½.

ğŸ¯ Listenerë„ ë‹¨ì¼í™” â†’ ìš”ì²­ë§ˆë‹¤ ìƒì„±/ì†Œë©¸ ë¶ˆí•„ìš”.

ğŸ§© correlationId ê¸°ë°˜ ë§¤í•‘ â†’ ì–´ë–¤ ì‘ë‹µì´ ì–´ë–¤ ìš”ì²­ì— ëŒ€í•œ ê²ƒì¸ì§€ ì•ˆì „í•˜ê²Œ ì‹ë³„.

â³ Future + Timeout â†’ ìš”ì²­ íƒ€ì„ì•„ì›ƒì„ ê¹”ë”í•˜ê²Œ ì²˜ë¦¬.

ğŸ“¡ ë¹„ë™ê¸° ì‘ë‹µ ì²˜ë¦¬ â†’ Vue3 í”„ë¡ íŠ¸ì—”ë“œë¡œ ë°”ë¡œ ì „ë‹¬ ê°€ëŠ¥.

íƒœì›ë‹˜, ì´ë ‡ê²Œ êµ¬ì¡°ë¥¼ ì¡ìœ¼ë©´ ìš”ì²­ì´ ìˆ˜ë°±/ìˆ˜ì²œ ê°œ ë“¤ì–´ì™€ë„ ë¦¬ìŠ¤ë„ˆ/íŠ¸ëœìŠ¤í¬íŠ¸ í­ì¦ ë¬¸ì œ ì—†ì´ ì•ˆì •ì ìœ¼ë¡œ ìš´ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ğŸ‘‰ í˜¹ì‹œ ì œê°€ correlationIdë¥¼ TibrvMsg.update("correlationId", ...) ë¡œ ë„£ì€ ê²Œ ë§ë‚˜ìš”? ì•„ë‹ˆë©´ íƒœì›ë‹˜ ì‹œìŠ¤í…œì—ì„œëŠ” ì´ë¯¸ header ê°™ì€ í•„ë“œë¡œ êµ¬ë¶„í•˜ê³  ê³„ì‹ ê°€ìš”?

ë‚˜ì˜ ë§:
ê·¸ëŸ°ë° ë‚˜ëŠ” Transportì£¼ì†Œê°€ ì—„ì²­ ë™ì ìœ¼ë¡œ ë°”ê»´ì•¼ í•´, ê·¸ë¦¬ê³  ë©”ì‹œì§€ í‚¤ëŠ” vue3ì—ì„œ ë³´ë‚´ì£¼ëŠ” millitime í‚¤ê°€ ìˆì–´,, 
ChatGPTì˜ ë§:

ì•„, íƒœì›ë‹˜ ìƒí™©ì´ ì´ì œ ë” ëª…í™•í•´ì¡Œë„¤ìš” ğŸ‘

Transport ì£¼ì†Œê°€ ìš”ì²­ë§ˆë‹¤ ë‹¬ë¼ì§„ë‹¤ â†’ ê³ ì • transport ì¬ì‚¬ìš©ì´ ì–´ë µê³ , ìš”ì²­ ë‹¨ìœ„ë¡œ TibrvTransportë¥¼ ìƒˆë¡œ ì—´ì–´ì•¼ í•  ìˆ˜ë„ ìˆìŒ.

Vue3ì—ì„œ millitime í‚¤ë¥¼ ë³´ë‚¸ë‹¤ â†’ ì´ê±¸ correlationId ëŒ€ì‹  ê·¸ëŒ€ë¡œ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤.

ì ‘ê·¼ ë°©ë²• 2ê°€ì§€
1. Transportë¥¼ ìš”ì²­ë§ˆë‹¤ ìƒì„±í•˜ëŠ” ë°©ì‹ (íƒœì›ë‹˜ ìƒí™© ë§ì¶¤)

ë‹¨ì : Transport ìƒì„±/í•´ì œ ë¹„ìš©ì´ í¼.

ì¥ì : ì£¼ì†Œê°€ ë§¤ë²ˆ ë‹¬ë¼ì ¸ë„ ìœ ì—°í•˜ê²Œ ëŒ€ì‘.

public void sendRequest(String payload, String service, String network, String daemon,
                        String millitimeKey, MessagePublisher publisher) throws TibrvException {

    // ìš”ì²­ë³„ Transport ìƒì„±
    TibrvTransport transport = new TibrvRvdTransport(service, network, daemon);

    // ìš”ì²­ ë©”ì‹œì§€
    TibrvMsg requestMsg = new TibrvMsg();
    requestMsg.setSendSubject("MY.REQUEST.SUBJECT");
    requestMsg.update("millitime", millitimeKey);
    requestMsg.update("data", payload);
    requestMsg.setReplySubject("MY.REPLY.SUBJECT");

    // Future ë“±ë¡
    CompletableFuture<TibrvMsg> future = new CompletableFuture<>();
    pendingRequests.put(millitimeKey, future);

    // íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬
    scheduler.schedule(() -> {
        CompletableFuture<TibrvMsg> f = pendingRequests.remove(millitimeKey);
        if (f != null && !f.isDone()) {
            f.completeExceptionally(new TimeoutException("Request timeout"));
            publisher.sendToClients("TIMEOUT: " + payload);
        }
        try {
            transport.destroy(); // ìš”ì²­ ì¢…ë£Œ í›„ Transport ì •ë¦¬
        } catch (TibrvException ignored) {}
    }, 10, TimeUnit.SECONDS);

    // ë©”ì‹œì§€ ì†¡ì‹ 
    transport.send(requestMsg);

    // ì‘ë‹µ ì™„ë£Œ ì‹œ Vue3ë¡œ ì „ë‹¬
    future.whenComplete((msg, ex) -> {
        try {
            transport.destroy(); // ì‘ë‹µ í›„ Transport í•´ì œ
        } catch (TibrvException ignored) {}

        if (ex == null) {
            publisher.sendToClients(msg.toString());
        } else {
            publisher.sendToClients("ERROR: " + ex.getMessage());
        }
    });
}

2. Transport Pooling (ë” íš¨ìœ¨ì ì¸ ë°©ì‹)

ìì£¼ ì“°ëŠ” ì£¼ì†Œ ì¡°í•©(service/network/daemon)ì„ Keyë¡œ í’€ë§(Map) í•´ì„œ Transportë¥¼ ì¬ì‚¬ìš©.

Vue3ì—ì„œ ì˜¤ëŠ” millitimeë§Œ correlationIdë¡œ í™œìš©.

private final Map<String, TibrvTransport> transportPool = new ConcurrentHashMap<>();

private TibrvTransport getOrCreateTransport(String service, String network, String daemon) throws TibrvException {
    String key = service + "|" + network + "|" + daemon;
    return transportPool.computeIfAbsent(key, k -> {
        try {
            return new TibrvRvdTransport(service, network, daemon);
        } catch (TibrvException e) {
            throw new RuntimeException(e);
        }
    });
}


â†’ ì´ê±¸ë¡œ transport = getOrCreateTransport(service, network, daemon) í˜¸ì¶œí•´ì„œ ì¬ì‚¬ìš©í•˜ë©´ ì„±ëŠ¥ í›¨ì”¬ ì¢‹ì•„ì§.

3. ë¦¬ìŠ¤ë„ˆëŠ” ì—¬ì „íˆ ì‹±ê¸€í†¤

ì‘ë‹µ ë©”ì‹œì§€(MY.REPLY.SUBJECT)ëŠ” ê·¸ëŒ€ë¡œ í•˜ë‚˜ì˜ Listenerê°€ ë°›ì•„ì„œ,
msg.get("millitime") ê°’ì„ êº¼ë‚´ pendingRequestsì—ì„œ ì°¾ì•„ complete.

private void onResponseMsg(TibrvListener listener, TibrvMsg msg) {
    try {
        String millitimeKey = (String) msg.get("millitime");
        CompletableFuture<TibrvMsg> future = pendingRequests.remove(millitimeKey);
        if (future != null) {
            future.complete(msg);
        }
    } catch (TibrvException e) {
        e.printStackTrace();
    }
}


âœ… ì •ë¦¬

Transport ì£¼ì†Œê°€ ê³„ì† ë°”ë€ë‹¤ë©´ â†’ í’€ë§ ë°©ì‹ ì¶”ì²œ (ì•ˆ ì“°ëŠ” TransportëŠ” ì£¼ê¸°ì ìœ¼ë¡œ cleanup).

Vue3ì—ì„œ ë³´ë‚´ì£¼ëŠ” millitimeì€ ê·¸ëŒ€ë¡œ correlationId ì—­í• ì„ í•˜ë©´ ë”± ë§ìŒ.

íƒœì›ë‹˜, í˜¹ì‹œ ì£¼ì†Œ(service, network, daemon) ì¡°í•©ì´ ê±°ì˜ ë§¤ë²ˆ ë‹¤ë¥´ê²Œ ë°”ë€Œë‚˜ìš”?
ì•„ë‹ˆë©´ ëª‡ ê°€ì§€ ì •í•´ì§„ ì¡°í•© ì•ˆì—ì„œë§Œ ë°”ë€Œë‚˜ìš”?
ì´ê±°ì— ë”°ë¼ í’€ë§ ë°©ì‹ì´ ì¢‹ì€ì§€, ìš”ì²­ë§ˆë‹¤ ìƒì„±ì´ ë” ì í•©í•œì§€ê°€ ê°ˆë¦½ë‹ˆë‹¤.

ë‚˜ì˜ ë§:
ëª‡ì‹­ê¹Œì§€ ì •í•´ì§„ ì¡°í•©ì•ˆì—ì„œ ë°”ë€Œì§€,
ChatGPTì˜ ë§:

ì¢‹ìŠµë‹ˆë‹¤ íƒœì›ë‹˜ ğŸ™Œ
ê·¸ëŸ¼ í™•ì‹¤íˆ í’€ë§ ë°©ì‹ì´ ì •ë‹µì´ì—ìš”.

ì™œ í’€ë§ì´ ìœ ë¦¬í•˜ëƒ?

ì¡°í•©ì´ ìˆ˜ì‹­ ê°œ ìˆ˜ì¤€ â†’ Transportë¥¼ ìš”ì²­ë§ˆë‹¤ ë§Œë“¤ê³  íŒŒê´´í•˜ëŠ” ê±´ ë‚­ë¹„.

TibrvTransportëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ì†Œì¼“/ì„¸ì…˜ì„ ì¡ê³  ìˆì–´ì„œ ë¬´ê²ìŠµë‹ˆë‹¤.

í•œ ë²ˆ ë§Œë“¤ì–´ ë‘” Transportë¥¼ Mapì— ìºì‹±í•´ë‘ë©´, í•„ìš”í•  ë•Œ ë¹ ë¥´ê²Œ êº¼ë‚´ ì“¸ ìˆ˜ ìˆê³  ì„±ëŠ¥ë„ ì•ˆì •ì ì´ì—ìš”.

êµ¬ì¡° ì œì•ˆ
1. Transport Pool
private final Map<String, TibrvTransport> transportPool = new ConcurrentHashMap<>();

private TibrvTransport getOrCreateTransport(String service, String network, String daemon) throws TibrvException {
    String key = service + "|" + network + "|" + daemon;
    return transportPool.computeIfAbsent(key, k -> {
        try {
            return new TibrvRvdTransport(service, network, daemon);
        } catch (TibrvException e) {
            throw new RuntimeException(e);
        }
    });
}

2. ìš”ì²­ ì²˜ë¦¬ (millitime â†’ correlationId ì—­í• )
public void sendRequest(String payload, String service, String network, String daemon,
                        String millitimeKey, MessagePublisher publisher) throws TibrvException {

    // í’€ì—ì„œ Transport ê°€ì ¸ì˜¤ê¸°
    TibrvTransport transport = getOrCreateTransport(service, network, daemon);

    // ìš”ì²­ ë©”ì‹œì§€
    TibrvMsg requestMsg = new TibrvMsg();
    requestMsg.setSendSubject("MY.REQUEST.SUBJECT");
    requestMsg.update("millitime", millitimeKey); // correlationId ëŒ€ì²´
    requestMsg.update("data", payload);
    requestMsg.setReplySubject("MY.REPLY.SUBJECT");

    // Future ìƒì„± & ë“±ë¡
    CompletableFuture<TibrvMsg> future = new CompletableFuture<>();
    pendingRequests.put(millitimeKey, future);

    // íƒ€ì„ì•„ì›ƒ ìŠ¤ì¼€ì¤„
    scheduler.schedule(() -> {
        CompletableFuture<TibrvMsg> f = pendingRequests.remove(millitimeKey);
        if (f != null && !f.isDone()) {
            f.completeExceptionally(new TimeoutException("Request timeout"));
            publisher.sendToClients("TIMEOUT: " + payload);
        }
    }, 10, TimeUnit.SECONDS);

    // ë©”ì‹œì§€ ì†¡ì‹ 
    transport.send(requestMsg);

    // ì‘ë‹µ ì™„ë£Œ â†’ Vue3 ì „ì†¡
    future.whenComplete((msg, ex) -> {
        if (ex == null) {
            publisher.sendToClients(msg.toString());
        } else {
            publisher.sendToClients("ERROR: " + ex.getMessage());
        }
    });
}

3. ì‘ë‹µ ë¦¬ìŠ¤ë„ˆ (ì‹±ê¸€í†¤)
private void onResponseMsg(TibrvListener listener, TibrvMsg msg) {
    try {
        String millitimeKey = (String) msg.get("millitime");
        CompletableFuture<TibrvMsg> future = pendingRequests.remove(millitimeKey);
        if (future != null) {
            future.complete(msg);
        }
    } catch (TibrvException e) {
        e.printStackTrace();
    }
}

4. Transport ì •ë¦¬ ì „ëµ (ì˜µì…˜)

ëª‡ì‹­ ê°œë¼ë©´ ê³„ì† ë“¤ê³  ìˆì–´ë„ í° ë¬¸ì œ ì—†ìŒ.

ê·¸ë˜ë„ ì•ˆì „í•˜ê²Œ í•˜ë ¤ë©´:

LRU ìºì‹œ ë°©ì‹ â†’ ì¼ì • ì‹œê°„ ì•ˆ ì“°ì¸ TransportëŠ” destroy() í›„ ì œê±°.

ì˜ˆ: ScheduledExecutorServiceë¡œ 10ë¶„ë§ˆë‹¤ transportPool ìŠ¤ìº”.

âœ… ì´ë ‡ê²Œ í•˜ë©´:

Vue3ì—ì„œ ë³´ë‚´ì£¼ëŠ” millitime â†’ ê·¸ëŒ€ë¡œ correlationId ì—­í• .

TransportëŠ” í’€ë§í•´ì„œ ì¬ì‚¬ìš©.

ListenerëŠ” ë‹¨ì¼ë¡œë§Œ ë‘ê³  ì‘ë‹µ ë§¤ì¹­.

íƒœì›ë‹˜, ì œê°€ í’€ë§ì— **LRU(ì˜¤ë«ë™ì•ˆ ì•ˆ ì“°ì¸ Transport ì •ë¦¬)**ê¹Œì§€ êµ¬í˜„í•´ ë“œë¦´ê¹Œìš”?
ì•„ë‹ˆë©´ ëª‡ì‹­ ê°œëŠ” ê·¸ëƒ¥ ìƒì‹œ ìœ ì§€í•˜ëŠ” ê±¸ë¡œ ì¶©ë¶„í•˜ì‹¤ê¹Œìš”?

























































































1ï¸âƒ£ Tibrv.open ë° ë””ìŠ¤íŒ¨ì¹˜ ì“°ë ˆë“œ
@PostConstruct
public void init() {
    Tibrv.open(Tibrv.IMPL_NATIVE);
    new Thread(() -> { while(true) { Tibrv.defaultQueue().dispatch(); } }, "RV-Dispatch-Thread").start();
}

ë¬¸ì œì 

ë¬´í•œ ë£¨í”„ ë””ìŠ¤íŒ¨ì¹˜

while(true) { dispatch(); }ëŠ” CPUë¥¼ ê±°ì˜ 100% ì‚¬ìš©í•˜ì§€ëŠ” ì•Šì§€ë§Œ, ë©”ì‹œì§€ê°€ ì—†ì„ ê²½ìš°ì—ë„ ê³„ì† ë£¨í”„ë¥¼ ëŒê²Œ ë©ë‹ˆë‹¤.

TibrvQueueì˜ dispatch()ëŠ” ë¸”ë¡œí‚¹ ëª¨ë“œë¡œ í˜¸ì¶œí•˜ëŠ” ê²ƒì´ ì•ˆì „í•©ë‹ˆë‹¤. dispatch() ëŒ€ì‹  queue.dispatch(Tibrv.INFINITE)ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤.

ì˜ˆì™¸ ì²˜ë¦¬ ë¶€ì¬

dispatch() ë‚´ë¶€ì—ì„œ ì˜ˆì™¸ê°€ ë°œìƒí•˜ë©´ ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë”°ë¼ì„œ try-catchë¡œ ê°ì‹¸ì„œ ë¡œê·¸ ì¶œë ¥ í›„ ì¬ì‹œì‘í•˜ëŠ” êµ¬ì¡°ê°€ í•„ìš”í•©ë‹ˆë‹¤.

ê°œì„  ì˜ˆ
@PostConstruct
public void init() {
    Tibrv.open(Tibrv.IMPL_NATIVE);
    Thread dispatchThread = new Thread(() -> {
        while(true) {
            try {
                Tibrv.defaultQueue().dispatch(Tibrv.INFINITE); // ë¸”ë¡œí‚¹ ëª¨ë“œ
            } catch (TibrvException e) {
                log.error("Tibrv Dispatch Error", e);
            }
        }
    }, "RV-Dispatch-Thread");
    dispatchThread.setDaemon(true);
    dispatchThread.start();
}

2ï¸âƒ£ TibrvListener ìƒì„±/íŒŒê´´ êµ¬ì¡°
TibrvListener listener = new TibrvListener(queue, callback, transport, replySubject, null);

ë¬¸ì œì 

Listener ìƒì„± ì‹œ transport ì‚¬ìš©

í˜„ì¬ new TibrvTransport()ë¥¼ ë§¤ ìš”ì²­ë§ˆë‹¤ ìƒˆë¡œ ë§Œë“¤ê³  ìˆìŠµë‹ˆë‹¤.

TibrvTransportëŠ” ìƒì„± ë¹„ìš©ì´ í¬ê³ , OS ë¦¬ì†ŒìŠ¤ë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ ê°€ëŠ¥í•œ ì¬ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

Listener destroy

Timeout ì‹œ ë˜ëŠ” ë©”ì‹œì§€ ìˆ˜ì‹  í›„ listener.destroy()ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.

ë§Œì•½ ë©”ì‹œì§€ì™€ Timeoutê°€ ê±°ì˜ ë™ì‹œì— ë°œìƒí•˜ë©´, listenerê°€ ì´ë¯¸ destroyëœ ìƒíƒœì—ì„œ ì¬ì ‘ê·¼ ê°€ëŠ¥ì„±ì´ ìˆìŠµë‹ˆë‹¤.

ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ë™ê¸°í™” ë¬¸ì œ ë°œìƒ ê°€ëŠ¥.

PendingRequests mapê³¼ listener lifecycle

mapê³¼ listenerê°€ ë³„ê°œë¡œ ì¡´ì¬ â†’ race condition ê°€ëŠ¥.

listenerê°€ ì•„ì§ ìƒì„± ì¤‘ì´ê±°ë‚˜ destroy ì¤‘ì¸ë° schedulerê°€ ì ‘ê·¼í•˜ë©´ NPE ë°œìƒ ê°€ëŠ¥.

ê°œì„ 

Transport ì¬ì‚¬ìš©: ê¸€ë¡œë²Œ pool ìƒì„± í›„ ì¬ì‚¬ìš©

Listener ê´€ë¦¬: listenerë¥¼ pendingRequests mapê³¼ ë¬¶ì–´ì„œ atomicí•˜ê²Œ ê´€ë¦¬

ë©€í‹°ìŠ¤ë ˆë“œ ë™ê¸°í™”: ConcurrentHashMap + AtomicReference ë˜ëŠ” synchronized ì‚¬ìš©

3ï¸âƒ£ Scheduler ì‚¬ìš© (Timeout)
scheduler.schedule(() -> {
    if(listener != null) {
        TibrvMsg lazyMsg = pendingRequests.get(header);
        // timeout ì²˜ë¦¬
        listener.destroy();
    }
}, 10, TimeUnit.SECONDS);

ë¬¸ì œì 

listener destroy race

ìœ„ì—ì„œ ì–¸ê¸‰í–ˆë“¯, listenerê°€ ì´ë¯¸ ë©”ì‹œì§€ë¥¼ ë°›ê³  destroyëì„ ê°€ëŠ¥ì„± ìˆìŒ.

ì•ˆì „í•˜ê²Œ ì²´í¬í•˜ë ¤ë©´ AtomicBoolean destroyed í”Œë˜ê·¸ í•„ìš”.

ìŠ¤ì¼€ì¤„ëŸ¬ ê³ ì • í’€

10ê°œì˜ thread pool ì‚¬ìš© ì‹œ, ë™ì‹œì— 10ê±´ ì´ìƒ ìš”ì²­ì´ ì˜¤ë©´ ìŠ¤ì¼€ì¤„ë§ ì§€ì—° ê°€ëŠ¥.

ì‘ì€ ê·œëª¨ í…ŒìŠ¤íŠ¸ì—ì„œëŠ” ë¬¸ì œì—†ì§€ë§Œ, ì‹¤ì œ ìš´ì˜ í™˜ê²½ì—ì„œ burst ìš”ì²­ ë°œìƒ ì‹œ Timeout ì²˜ë¦¬ê°€ ì§€ì—°ë  ìˆ˜ ìˆìŒ.

ì§€ì—° dispatch í˜¸ì¶œ

transport.send(requestMsg); Tibrv.defaultQueue().dispatch();ëŠ” ì¼ë°˜ì ìœ¼ë¡œ dispatch ìŠ¤ë ˆë“œì—ì„œ í˜¸ì¶œí•´ì•¼ í•©ë‹ˆë‹¤.

ì—¬ê¸°ì„œ dispatchë¥¼ í˜¸ì¶œí•˜ë©´ main dispatch ìŠ¤ë ˆë“œì™€ ì¶©ëŒ ê°€ëŠ¥ì„±ì´ ìˆìŠµë‹ˆë‹¤.

ê°œì„ 

Timeout ì²´í¬ëŠ” listenerì˜ callback ì•ˆì—ì„œ ì²˜ë¦¬í•˜ê±°ë‚˜, ScheduledExecutorService ëŒ€ì‹  TibrvQueue timer ì‚¬ìš© ê°€ëŠ¥

Scheduler pool ì‚¬ì´ì¦ˆë¥¼ íŠ¸ë˜í”½ ê¸°ë°˜ìœ¼ë¡œ ì¡°ì •í•˜ê±°ë‚˜, ì‘ì—…ëŸ‰ì„ ëª¨ë‹ˆí„°ë§

4ï¸âƒ£ Transport ë° MessagePublisher

TibrvTransport transport = new TibrvTransport();ë¥¼ ë§¤ ìš”ì²­ë§ˆë‹¤ ìƒˆë¡œ ë§Œë“œëŠ” êµ¬ì¡°ëŠ” ë¦¬ì†ŒìŠ¤ ë‚­ë¹„ê°€ í¼.

ê°œì„ :

Transport Pool ì‚¬ìš©

ConcurrentHashMap<String, TibrvTransport> ë˜ëŠ” Spring Bean singletonìœ¼ë¡œ ìœ ì§€

MessagePublisherë„ ë¹„ë™ê¸° ì²˜ë¦¬ ê¶Œì¥

ë©”ì‹œì§€ ë°œì†¡ì´ blockingì´ë©´ ì „ì²´ listener ì„±ëŠ¥ ì €í•˜

5ï¸âƒ£ ê¸°íƒ€ ì ì¬ì  ë¬¸ì œ

ë©”ì‹œì§€ ì¤‘ë³µ ìˆ˜ì‹ 

Listenerê°€ ìƒì„± â†’ ìˆ˜ì‹  â†’ destroy ìˆœìœ¼ë¡œ ë˜ì–´ìˆì–´, ë©”ì‹œì§€ ì§€ì—° ì‹œ ë‘ ë²ˆ ìˆ˜ì‹ ë  ê°€ëŠ¥ì„± ì¡´ì¬

ëŒ€ê·œëª¨ íŠ¸ë˜í”½

pendingRequests mapì´ ì»¤ì§€ë©´ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°€ëŠ¥

Scheduler poolì´ ë°”ì  ê²½ìš°, Timeout ë©”ì‹œì§€ê°€ ì§€ì—°ë˜ê±°ë‚˜ ëˆ„ë½ë  ìˆ˜ ìˆìŒ

ì˜ˆì™¸ ì²˜ë¦¬

í˜„ì¬ ì½”ë“œì—ì„œëŠ” TibrvException, RuntimeException ë“±ì— ëŒ€í•œ ì¤‘ì•™ ê´€ë¦¬ê°€ ì—†ìŒ

ì¶”ì²œ: ê¸€ë¡œë²Œ ExceptionHandler + retry/logging êµ¬ì¡°

ğŸ”¹ ìš”ì•½: ê°œì„  ê¶Œì¥ ì‚¬í•­
í•­ëª©	ê¶Œì¥ ê°œì„ 
Dispatch ìŠ¤ë ˆë“œ	dispatch(Tibrv.INFINITE) + try-catch + daemon thread
Transport	ì¬ì‚¬ìš©, ìš”ì²­ë§ˆë‹¤ ìƒì„±í•˜ì§€ ì•ŠìŒ
Listener	Atomic ê´€ë¦¬, destroy race ë°©ì§€
Timeout	Scheduler pool ì‚¬ì´ì¦ˆ ì¡°ì •, ë˜ëŠ” TibrvTimer ì‚¬ìš©
PendingRequests	ConcurrentHashMap + atomic flag
Exception	ëª¨ë“  TibrvException, RuntimeException ë¡œê¹… ë° ì¬ì‹œë„
ë©”ì‹œì§€ ë°œì†¡	ë¹„ë™ê¸° ì²˜ë¦¬, block ë°©ì§€

íƒœì›ë‹˜, ì •ë¦¬í•˜ë©´ ì§€ê¸ˆ êµ¬ì¡°ëŠ” ì‘ì€ ìƒ˜í”Œì—ì„œëŠ” ë¬¸ì œì—†ì§€ë§Œ, ìš´ì˜ í™˜ê²½ì—ì„œëŠ” listener destroy race, transport ì¬ì‚¬ìš©, scheduler pool ê³ ê°ˆ ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì›í•˜ì‹œë©´ ì œê°€ ìš´ì˜ í™˜ê²½ì—ì„œë„ ì•ˆì •ì ì¸ Tibrv ìš”ì²­-ì‘ë‹µ êµ¬ì¡° ì˜ˆì œë¥¼ ë§Œë“¤ì–´ì„œ ë³´ì—¬ë“œë¦´ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
í˜¹ì‹œ ê·¸ìª½ìœ¼ë¡œë„ ë§Œë“¤ì–´ ë“œë¦´ê¹Œìš”?

ë‚˜ì˜ ë§:
ì™„ë²½í•˜ê²Œ ìˆ˜ì •ëœ ì „ì²´ ì†ŒìŠ¤ë¥¼ ë³´ì—¬ì¤˜
ChatGPTì˜ ë§:

ì¢‹ìŠµë‹ˆë‹¤, íƒœì›ë‹˜. ë§ì”€í•˜ì‹  ë‚´ìš©ì„ ëª¨ë‘ ë°˜ì˜í•´ì„œ ìš´ì˜ í™˜ê²½ì—ì„œë„ ì•ˆì •ì ì¸ Spring Boot + TIBCO RV êµ¬ì¡°ë¥¼ ì™„ì „íˆ ì¬ì‘ì„±í•´ë³´ê² ìŠµë‹ˆë‹¤.

íŠ¹ì§•:

Tibrv.open í•œ ë²ˆë§Œ í˜¸ì¶œ

ë””ìŠ¤íŒ¨ì¹˜ ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹ ëª¨ë“œ + ì˜ˆì™¸ ì²˜ë¦¬ + ë°ëª¬ ìŠ¤ë ˆë“œ

Transport ì¬ì‚¬ìš©

Listener lifecycle ì•ˆì „ ê´€ë¦¬ (AtomicBooleanìœ¼ë¡œ destroy race ë°©ì§€)

PendingRequests Map thread-safe

Timeout ì²˜ë¦¬ scheduler ì‚¬ìš©

MessagePublisher ë¹„ë™ê¸° ë°œì†¡

package com.example.rv;

import com.example.rv.publisher.MessagePublisher;
import org.springframework.stereotype.Component;

import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import com.tibco.tibrv.*;

@Component
public class TibrvService {

    private final MessagePublisher messagePublisher;

    // Thread-safe Mapìœ¼ë¡œ pending request ê´€ë¦¬
    private final Map<String, PendingRequest> pendingRequests = new ConcurrentHashMap<>();

    // Scheduler for timeout
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(10);

    // ì¬ì‚¬ìš© ê°€ëŠ¥í•œ transport pool (ì˜ˆì‹œ: 1ê°œ)
    private TibrvTransport transport;

    public TibrvService(MessagePublisher messagePublisher) {
        this.messagePublisher = messagePublisher;
    }

    // 1ï¸âƒ£ Tibrv ì´ˆê¸°í™”
    @PostConstruct
    public void init() throws TibrvException {
        Tibrv.open(Tibrv.IMPL_NATIVE);

        // ì¬ì‚¬ìš© ê°€ëŠ¥í•œ transport ìƒì„±
        transport = new TibrvTransport("RVService", null, null);

        // ë””ìŠ¤íŒ¨ì¹˜ ìŠ¤ë ˆë“œ ì‹œì‘
        Thread dispatchThread = new Thread(() -> {
            while (true) {
                try {
                    Tibrv.defaultQueue().dispatch(Tibrv.INFINITE); // ë¸”ë¡œí‚¹ ëª¨ë“œ
                } catch (TibrvException e) {
                    e.printStackTrace(); // ë¡œê¹…
                }
            }
        }, "RV-Dispatch-Thread");
        dispatchThread.setDaemon(true);
        dispatchThread.start();
    }

    // 2ï¸âƒ£ ìš”ì²­ ì²˜ë¦¬
    public void sendRequest(String requestId, String replySubject, String payload) throws TibrvException {
        TibrvQueue queue = Tibrv.defaultQueue();

        // PendingRequest ê°ì²´ ìƒì„±
        PendingRequest pending = new PendingRequest(requestId, replySubject);
        pendingRequests.put(requestId, pending);

        // Listener ìƒì„±
        TibrvListener listener = new TibrvListener(queue, new TibrvMsgCallback() {
            @Override
            public void onMsg(TibrvListener listener, TibrvMsg msg) {
                if (!pending.destroyed.getAndSet(true)) {
                    // ë©”ì‹œì§€ ìˆ˜ì‹  ì²˜ë¦¬
                    messagePublisher.sendToClients(msg.getString("data")); // ì˜ˆì‹œ
                    pendingRequests.remove(requestId);
                    listener.destroy();
                }
            }
        }, transport, replySubject, null);
        pending.listener = listener;

        // Timeout ì˜ˆì•½
        scheduler.schedule(() -> {
            if (!pending.destroyed.getAndSet(true)) {
                // Timeout ì²˜ë¦¬
                messagePublisher.sendToClients("Timeout for requestId=" + requestId);
                pendingRequests.remove(requestId);
                if (pending.listener != null) pending.listener.destroy();
            }
        }, 10, TimeUnit.SECONDS);

        // ë©”ì‹œì§€ ì „ì†¡
        TibrvMsg requestMsg = new TibrvMsg();
        requestMsg.add("data", payload);
        transport.send(requestMsg);
    }

    // 3ï¸âƒ£ ì„œë¹„ìŠ¤ ì¢…ë£Œ ì‹œ cleanup
    @PreDestroy
    public void shutdown() {
        scheduler.shutdownNow();
        pendingRequests.forEach((k, v) -> {
            if (v.listener != null) {
                v.listener.destroy();
            }
        });
        pendingRequests.clear();
        if (transport != null) transport.destroy();
        try {
            Tibrv.close();
        } catch (TibrvException e) {
            e.printStackTrace();
        }
    }

    // 4ï¸âƒ£ PendingRequest ë‚´ë¶€ í´ë˜ìŠ¤
    private static class PendingRequest {
        final String requestId;
        final String replySubject;
        TibrvListener listener;
        final AtomicBoolean destroyed = new AtomicBoolean(false);

        PendingRequest(String requestId, String replySubject) {
            this.requestId = requestId;
            this.replySubject = replySubject;
        }
    }
}

âœ… ì£¼ìš” ê°œì„  í¬ì¸íŠ¸

Transport ì¬ì‚¬ìš©

ëª¨ë“  ìš”ì²­ì—ì„œ ìƒˆ Transportë¥¼ ë§Œë“¤ì§€ ì•Šê³ , ì´ˆê¸°í™” ì‹œ í•œ ë²ˆë§Œ ìƒì„±

Listener lifecycle ì•ˆì „

AtomicBoolean destroyed ì‚¬ìš© â†’ race condition ë°©ì§€

Timeoutê³¼ ì‹¤ì œ ë©”ì‹œì§€ ìˆ˜ì‹  ì‹œ ì¤‘ë³µ destroy ë°©ì§€

Scheduler + Timeout ì•ˆì „

10ì´ˆ í›„ Timeout ë°œìƒ ì‹œì—ë„ Listenerê°€ ì´ë¯¸ destroy ë˜ì—ˆìœ¼ë©´ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ

Dispatch ìŠ¤ë ˆë“œ ì•ˆì •í™”

ë¸”ë¡œí‚¹ ëª¨ë“œ + ì˜ˆì™¸ ì²˜ë¦¬ + daemon ìŠ¤ë ˆë“œ

PendingRequests Map

Thread-safe êµ¬ì¡°ë¡œ ìš”ì²­ ì¶”ì  ê°€ëŠ¥

íƒœì›ë‹˜, ì´ êµ¬ì¡°ë¼ë©´ ë™ì‹œ ë‹¤ì¤‘ ìš”ì²­ì—ë„ ì•ˆì „í•˜ë©°, Listener destroy race, Transport ê³¼ë‹¤ ìƒì„±, Timeout ì§€ì—° ë¬¸ì œë¥¼ ëª¨ë‘ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
